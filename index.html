<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Project2</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><h1 id="locally-weighted-regression-gramforts-version">Locally Weighted Regression: Gramfort’s Version</h1>
<p>We will be adapting a python function that performs a Locally Weighted Regression using Gramfort’s approach. The function is currently only suitable for single dimensional data and needs to be altered so that it can deal with multidimensional data as well.</p>
<h2 id="unedited-code-for-single-dimensional-features">Unedited Code for Single Dimensional Features</h2>
<p>Here, we have the single dimensional function:</p>
<pre class=" language-python"><code class="prism  language-python"><span class="token keyword">def</span>  <span class="token function">lowess_ag</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> f<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">.</span> <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token builtin">iter</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token triple-quoted-string string">"""lowess(x, y, f=2./3., iter=3) -&gt; yest
Lowess smoother: Robust locally weighted regression.
The lowess function fits a nonparametric regression curve to a scatterplot.
The arrays x and y contain an equal number of elements; each pair
(x[i], y[i]) defines a data point in the scatterplot. The function returns
the estimated (smooth) values of y.
The smoothing span is given by f. A larger value for f will result in a
smoother curve. The number of robustifying iterations is given by iter. The
function will run faster with a smaller number of iterations.
"""</span>
n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
r <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>ceil<span class="token punctuation">(</span>f <span class="token operator">*</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span>

h <span class="token operator">=</span> <span class="token punctuation">[</span>np<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>np<span class="token punctuation">.</span><span class="token builtin">abs</span><span class="token punctuation">(</span>x <span class="token operator">-</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span>  <span class="token keyword">for</span> i <span class="token keyword">in</span>  <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>

w <span class="token operator">=</span> np<span class="token punctuation">.</span>clip<span class="token punctuation">(</span>np<span class="token punctuation">.</span><span class="token builtin">abs</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span>  <span class="token boolean">None</span><span class="token punctuation">]</span> <span class="token operator">-</span> x<span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">,</span>  <span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">/</span> h<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token number">0.0</span><span class="token punctuation">,</span>  <span class="token number">1.0</span><span class="token punctuation">)</span>
w <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> w <span class="token operator">**</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">3</span>

yest <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>n<span class="token punctuation">)</span>
delta <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span>n<span class="token punctuation">)</span>

<span class="token keyword">for</span> iteration <span class="token keyword">in</span>  <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">iter</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">for</span> i <span class="token keyword">in</span>  <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
		weights <span class="token operator">=</span> delta <span class="token operator">*</span> w<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> i<span class="token punctuation">]</span>
		b <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span>np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>weights <span class="token operator">*</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>weights <span class="token operator">*</span> y <span class="token operator">*</span> x<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
		A <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span>np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>weights<span class="token punctuation">)</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>weights <span class="token operator">*</span> x<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
					  <span class="token punctuation">[</span>np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>weights <span class="token operator">*</span> x<span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>weights <span class="token operator">*</span> x <span class="token operator">*</span> x<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
		beta <span class="token operator">=</span> linalg<span class="token punctuation">.</span>solve<span class="token punctuation">(</span>A<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
		yest<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> beta<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> beta<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
	  
	residuals <span class="token operator">=</span> y <span class="token operator">-</span> yest
	s <span class="token operator">=</span> np<span class="token punctuation">.</span>median<span class="token punctuation">(</span>np<span class="token punctuation">.</span><span class="token builtin">abs</span><span class="token punctuation">(</span>residuals<span class="token punctuation">)</span><span class="token punctuation">)</span>
	delta <span class="token operator">=</span> np<span class="token punctuation">.</span>clip<span class="token punctuation">(</span>residuals <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">6.0</span> <span class="token operator">*</span> s<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">)</span>
	delta <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> delta <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">2</span>

<span class="token keyword">return</span> yest
</code></pre>
<h2 id="updating-code-portions-for-multidimensional-cases">Updating Code Portions for Multidimensional Cases</h2>
<p>For this section, we will need to change some existing lines of code and add new lines of code as well.</p>
<p>To start off, we will need to change how the function deals with single dimensional data. All we need to do here is check for single dimensional data and convert it into a column vector:</p>
<pre class=" language-python"><code class="prism  language-python"><span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>y<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>
	y <span class="token operator">=</span> y<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>  

<span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>
	x <span class="token operator">=</span> x<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>
</code></pre>
<p>Next, we want to introduce the concept of an intercept. This is just like in algebra how we have the intercept, <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathnormal">b</span></span></span></span></span>, in <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>y</mi><mo>=</mo><mi>m</mi><mi>x</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">y = mx + b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathnormal" style="margin-right: 0.03588em;">y</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathnormal">b</span></span></span></span></span></span> Instead of having a single intercept, a multidimensional dataset will require an additional column vector of 1’s. This will allow our regression to not be forced through the origin:</p>
<pre class=" language-python"><code class="prism  language-python"><span class="token keyword">if</span> intercept<span class="token punctuation">:</span>
	x1 <span class="token operator">=</span> np<span class="token punctuation">.</span>column_stack<span class="token punctuation">(</span><span class="token punctuation">[</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
	x1 <span class="token operator">=</span> x
</code></pre>
<p>Like in <a href="https://matthewcheng13.github.io/Project1-AAML/">Project 1</a>, we once again need to visit Euclidean distance:<br>
<span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy="false">(</mo><mover accent="true"><mi>v</mi><mo>⃗</mo></mover><mo separator="true">,</mo><mover accent="true"><mi>w</mi><mo>⃗</mo></mover><mo stretchy="false">)</mo><mo>=</mo><msqrt><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mn>1</mn></msub><mo>−</mo><msub><mi>w</mi><mn>1</mn></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><mo stretchy="false">(</mo><msub><mi>v</mi><mn>2</mn></msub><mo>−</mo><msub><mi>w</mi><mn>2</mn></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo stretchy="false">(</mo><msub><mi>v</mi><mi>p</mi></msub><mo>−</mo><msub><mi>w</mi><mi>p</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></msqrt></mrow><annotation encoding="application/x-tex"> dist(\vec{v},\vec{w})=\sqrt{(v_1-w_1)^2+(v_2-w_2)^2+...(v_p-w_p)^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.714em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord mathnormal" style="margin-right: 0.03588em;">v</span></span><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="accent-body" style="left: -0.20772em;"><span class="overlay" style="height: 0.714em; width: 0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"></path></svg></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.714em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord mathnormal" style="margin-right: 0.02691em;">w</span></span><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="accent-body" style="left: -0.15216em;"><span class="overlay" style="height: 0.714em; width: 0.471em;"><svg width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z"></path></svg></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.84em; vertical-align: -0.574179em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.26582em;"><span class="svg-align" style="top: -3.8em;"><span class="pstrut" style="height: 3.8em;"></span><span class="mord" style="padding-left: 1em;"><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.02691em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.740108em;"><span class="" style="top: -2.989em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.02691em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.740108em;"><span class="" style="top: -2.989em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord">...</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: -0.02691em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"><span class=""></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.740108em;"><span class="" style="top: -2.989em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span class="" style="top: -3.22582em;"><span class="pstrut" style="height: 3.8em;"></span><span class="hide-tail" style="min-width: 1.02em; height: 1.88em;"><svg width="400em" height="1.8800000000000001em" viewBox="0 0 400000 1944" preserveAspectRatio="xMinYMin slice"><path d="M983 90
l0 -0
c4,-6.7,10,-10,18,-10 H400000v40
H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7
s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744
c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30
c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722
c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5
c53.7,-170.3,84.5,-266.8,92.5,-289.5z
M1001 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.574179em;"><span class=""></span></span></span></span></span></span></span></span></span></span>We will have this equation replace the distance calculation we were using before with single dimensional data, which was just finding the difference:<br>
<span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy="false">(</mo><mi>v</mi><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">)</mo><mo>=</mo><mi>v</mi><mo>−</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">dist(v,w) = v-w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathnormal" style="margin-right: 0.02691em;">w</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathnormal" style="margin-right: 0.03588em;">v</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal" style="margin-right: 0.02691em;">w</span></span></span></span></span></span></p>
<pre class=" language-python"><code class="prism  language-python"><span class="token comment"># one dimension</span>
h <span class="token operator">=</span> <span class="token punctuation">[</span>np<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>np<span class="token punctuation">.</span><span class="token builtin">abs</span><span class="token punctuation">(</span>x<span class="token operator">-</span>x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token comment"># multidimension</span>
h <span class="token operator">=</span> <span class="token punctuation">[</span>np<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token operator">-</span>x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">,</span>axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>
</code></pre>
<p>An additional feature that this equation has is the ability for the user to specify which kernel function they would like to use. In the original version, it is hardcoded to always be tricubic, however, the user may now specify quartic, exponential (Gaussian), or Epanechnikov.</p>
<p>For solving our system of equations, we previously used the summation of the products of the weights and the input data like so:</p>
<pre class=" language-python"><code class="prism  language-python">weights <span class="token operator">=</span> delta <span class="token operator">*</span> w<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> i<span class="token punctuation">]</span>
b <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span>np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>weights <span class="token operator">*</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>weights <span class="token operator">*</span> y <span class="token operator">*</span> x<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
A <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span>np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>weights<span class="token punctuation">)</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>weights <span class="token operator">*</span> x<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
			  <span class="token punctuation">[</span>np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>weights <span class="token operator">*</span> x<span class="token punctuation">)</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>weights <span class="token operator">*</span> x <span class="token operator">*</span> x<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
beta <span class="token operator">=</span> linalg<span class="token punctuation">.</span>solve<span class="token punctuation">(</span>A<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
yest<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> beta<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> beta<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
</code></pre>
<p>However, to accommodate higher dimensions, we will now be using the dot product to create a matrix equation. <em>linalg.solve(A, b)</em> is capable of solving a system of equations as well as a matrix equation, so this does not need to be changed. However, we will now require the weights matrix to be a diagonal matrix. We will accomplish this with <em>np.diag()</em>. Lastly, we do not need to worry about the one dimensional case, as this was already covered by converting the input x and y to be column vectors.</p>
<pre class=" language-python"><code class="prism  language-python">W <span class="token operator">=</span> np<span class="token punctuation">.</span>diag<span class="token punctuation">(</span>w<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
b <span class="token operator">=</span> np<span class="token punctuation">.</span>transpose<span class="token punctuation">(</span>x1<span class="token punctuation">)</span><span class="token punctuation">.</span>dot<span class="token punctuation">(</span>W<span class="token punctuation">)</span><span class="token punctuation">.</span>dot<span class="token punctuation">(</span>y<span class="token punctuation">)</span>
A <span class="token operator">=</span> np<span class="token punctuation">.</span>transpose<span class="token punctuation">(</span>x1<span class="token punctuation">)</span><span class="token punctuation">.</span>dot<span class="token punctuation">(</span>W<span class="token punctuation">)</span><span class="token punctuation">.</span>dot<span class="token punctuation">(</span>x1<span class="token punctuation">)</span>
A <span class="token operator">=</span> A <span class="token operator">+</span> <span class="token number">0.0001</span><span class="token operator">*</span>np<span class="token punctuation">.</span>eye<span class="token punctuation">(</span>x1<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
beta <span class="token operator">=</span> linalg<span class="token punctuation">.</span>solve<span class="token punctuation">(</span>A<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
yest<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> np<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>x1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>beta<span class="token punctuation">)</span>
</code></pre>
<p>We have also included L2 regularization that uses <em>np.eye()</em></p>
<p>Although this section did not need changing, there is an extra change made to the calculation of the outliers. In the original example, an approximation was used to estimate the outlier cutoff, <em>c</em>:<br>
<span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>c</mi><mo>=</mo><mn>6</mn><mi>s</mi></mrow><annotation encoding="application/x-tex">c = 6s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">6</span><span class="mord mathnormal">s</span></span></span></span></span></span>Here, s is the median of the absolute values of the residuals. Instead of approximating, our new function will calculate this outlier cutoff using the <em>IQR</em> (interquartile range). Assuming that <em>Q1</em> is the 25th percentile of the data values and <em>Q3</em> is the 75th percentile, the <em>IQR</em> can be easily calculated like so:<br>
<span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>I</mi><mi>Q</mi><mi>R</mi><mo>=</mo><mi>Q</mi><mn>3</mn><mo>−</mo><mi>Q</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">IQR = Q3-Q1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.87777em; vertical-align: -0.19444em;"></span><span class="mord mathnormal" style="margin-right: 0.07847em;">I</span><span class="mord mathnormal" style="margin-right: 0.00773em;">QR</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.87777em; vertical-align: -0.19444em;"></span><span class="mord mathnormal">Q</span><span class="mord">3</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.87777em; vertical-align: -0.19444em;"></span><span class="mord mathnormal">Q</span><span class="mord">1</span></span></span></span></span></span>We can then use this to calculate the upper and lower bounds for outliers:<br>
<span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>u</mi><mi>p</mi><mi>p</mi><mi>e</mi><mi>r</mi><mo>=</mo><mi>Q</mi><mn>3</mn><mo>+</mo><mo stretchy="false">(</mo><mn>1.5</mn><mo>∗</mo><mi>I</mi><mi>Q</mi><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">upper = Q3 + (1.5*IQR)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathnormal">u</span><span class="mord mathnormal">pp</span><span class="mord mathnormal" style="margin-right: 0.02778em;">er</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.87777em; vertical-align: -0.19444em;"></span><span class="mord mathnormal">Q</span><span class="mord">3</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1.5</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.07847em;">I</span><span class="mord mathnormal" style="margin-right: 0.00773em;">QR</span><span class="mclose">)</span></span></span></span></span></span><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mi>e</mi><mi>r</mi><mo>=</mo><mi>Q</mi><mn>1</mn><mo>−</mo><mo stretchy="false">(</mo><mn>1.5</mn><mo>∗</mo><mi>I</mi><mi>Q</mi><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">lower = Q1 - (1.5*IQR)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathnormal" style="margin-right: 0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right: 0.02691em;">w</span><span class="mord mathnormal" style="margin-right: 0.02778em;">er</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.87777em; vertical-align: -0.19444em;"></span><span class="mord mathnormal">Q</span><span class="mord">1</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1.5</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.07847em;">I</span><span class="mord mathnormal" style="margin-right: 0.00773em;">QR</span><span class="mclose">)</span></span></span></span></span></span>Lastly, we can standardize for each residual, <em>r</em>, so that the lower bound is -1 and the upper bound is 1:<br>
<span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>r</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub><mo>=</mo><mfrac><mrow><mi>r</mi><mo>−</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>u</mi><mi>p</mi><mi>p</mi><mi>e</mi><mi>r</mi><mo>−</mo><mi>l</mi><mi>o</mi><mi>w</mi><mi>e</mi><mi>r</mi><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow><mrow><mi>u</mi><mi>p</mi><mi>p</mi><mi>e</mi><mi>r</mi><mo>−</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>u</mi><mi>p</mi><mi>p</mi><mi>e</mi><mi>r</mi><mo>−</mo><mi>l</mi><mi>o</mi><mi>w</mi><mi>e</mi><mi>r</mi><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow></mfrac></mrow><annotation encoding="application/x-tex">r_{new} = \frac{r - \frac{(upper-lower)}2}{upper-\frac{(upper-lower)}2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: -0.02778em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right: 0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 2.99em; vertical-align: -1.245em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.745em;"><span class="" style="top: -2.11em;"><span class="pstrut" style="height: 3.01em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="mord mathnormal">pp</span><span class="mord mathnormal" style="margin-right: 0.02778em;">er</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.01em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.485em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">pp</span><span class="mord mathnormal mtight" style="margin-right: 0.02778em;">er</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right: 0.01968em;">l</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right: 0.02691em;">w</span><span class="mord mathnormal mtight" style="margin-right: 0.02778em;">er</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span class="" style="top: -3.24em;"><span class="pstrut" style="height: 3.01em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.745em;"><span class="pstrut" style="height: 3.01em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.02778em;">r</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.01em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.485em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">pp</span><span class="mord mathnormal mtight" style="margin-right: 0.02778em;">er</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right: 0.01968em;">l</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right: 0.02691em;">w</span><span class="mord mathnormal mtight" style="margin-right: 0.02778em;">er</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.245em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span>Using these bounds, we clip the outliers to be either -1 or 1. We then apply a quartic function to convert these values to weighted delta values:</p>
<pre class=" language-python"><code class="prism  language-python">mid <span class="token operator">=</span> <span class="token punctuation">(</span>upper <span class="token operator">+</span> lower<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span>
div <span class="token operator">=</span> upper<span class="token operator">-</span>mid

delta <span class="token operator">=</span> np<span class="token punctuation">.</span>clip<span class="token punctuation">(</span><span class="token punctuation">(</span>residuals <span class="token operator">-</span> mid<span class="token punctuation">)</span><span class="token operator">/</span>div<span class="token punctuation">,</span>  <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">)</span>
delta <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> delta <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">2</span>
</code></pre>
<p>Now, we are left with one problem: we do not have a way to deal with new data (testing data). Luckily this is simple for a one dimensional case, as we just use a 1D interpolator:</p>
<pre class=" language-python"><code class="prism  language-python">f <span class="token operator">=</span> interp1d<span class="token punctuation">(</span>x<span class="token punctuation">.</span>flatten<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>yest<span class="token punctuation">,</span>fill_value<span class="token operator">=</span><span class="token string">'extrapolate'</span><span class="token punctuation">)</span>
output <span class="token operator">=</span> f<span class="token punctuation">(</span>xnew<span class="token punctuation">)</span>
</code></pre>
<p>However, it is more complex for higher dimensions. Since there may be potential relationships across the features, a concept called <em>colinearity</em>, we must use principal component analysis to decide the three most important features in predicting our target variable (Note: this is done for each new observation). We can then use an ND (N-Dimension) Interpolator with these three features to get our final output:</p>
<pre class=" language-python"><code class="prism  language-python">output <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>xnew<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>xnew<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
	ind <span class="token operator">=</span> np<span class="token punctuation">.</span>argsort<span class="token punctuation">(</span>np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token operator">-</span>xnew<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">,</span>axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span>r<span class="token punctuation">]</span>
	pca <span class="token operator">=</span> PCA<span class="token punctuation">(</span>n_components<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span>
	x_pca <span class="token operator">=</span> pca<span class="token punctuation">.</span>fit_transform<span class="token punctuation">(</span>x<span class="token punctuation">[</span>ind<span class="token punctuation">]</span><span class="token punctuation">)</span>
	tri <span class="token operator">=</span> Delaunay<span class="token punctuation">(</span>x_pca<span class="token punctuation">,</span>qhull_options<span class="token operator">=</span><span class="token string">'QJ'</span><span class="token punctuation">)</span>
	f <span class="token operator">=</span> LinearNDInterpolator<span class="token punctuation">(</span>tri<span class="token punctuation">,</span>y<span class="token punctuation">[</span>ind<span class="token punctuation">]</span><span class="token punctuation">)</span>
	output<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">(</span>pca<span class="token punctuation">.</span>transform<span class="token punctuation">(</span>xnew<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
<p>One last inclusion we need is a way to deal with new x values that fall outside of the bounds of the old x values. These will be assigned NaN in the above step, so we need to use a nearest neighbor interpolation to fix that:</p>
<pre class=" language-python"><code class="prism  language-python"><span class="token keyword">if</span> <span class="token builtin">sum</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>isnan<span class="token punctuation">(</span>output<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">:</span>
	g <span class="token operator">=</span> NearestNDInterpolator<span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">.</span>ravel<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
output<span class="token punctuation">[</span>np<span class="token punctuation">.</span>isnan<span class="token punctuation">(</span>output<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> g<span class="token punctuation">(</span>xnew<span class="token punctuation">[</span>np<span class="token punctuation">.</span>isnan<span class="token punctuation">(</span>output<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre>
<h2 id="final-multidimensional-function">Final Multidimensional Function</h2>
<p>Now that we have summarized all of the changes we need to make to the original function, let’s see what the new multidimensional function looks like:</p>
<pre class=" language-python"><code class="prism  language-python"><span class="token keyword">def</span> <span class="token function">lowess_ag_md</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> xnew<span class="token punctuation">,</span> f<span class="token operator">=</span><span class="token number">2</span><span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token builtin">iter</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> intercept<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> kernel<span class="token operator">=</span><span class="token string">'tricubic'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
	n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
	  
	<span class="token comment"># calculating the amount of neighbors we are considering</span>
	r <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>ceil<span class="token punctuation">(</span>f <span class="token operator">*</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span>
	  
	<span class="token comment"># one dimensional y and x become column vectors here</span>
	<span class="token keyword">if</span>  <span class="token builtin">len</span><span class="token punctuation">(</span>y<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>
		y <span class="token operator">=</span> y<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>

	<span class="token keyword">if</span>  <span class="token builtin">len</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>
		x <span class="token operator">=</span> x<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>
	  
	<span class="token comment"># we need to add a column of ones to account for the intercept</span>
	<span class="token comment"># this is by default, however the user has the option to not</span>
	<span class="token comment"># include this step</span>
	<span class="token keyword">if</span> intercept<span class="token punctuation">:</span>
		x1 <span class="token operator">=</span> np<span class="token punctuation">.</span>column_stack<span class="token punctuation">(</span><span class="token punctuation">[</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span>
	<span class="token keyword">else</span><span class="token punctuation">:</span>
		x1 <span class="token operator">=</span> x
	  
	<span class="token comment"># calculating the Euclidean distance for each observation</span>
	h <span class="token operator">=</span> <span class="token punctuation">[</span>np<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token operator">-</span>x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">,</span>axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span>  <span class="token keyword">for</span> i <span class="token keyword">in</span>  <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>
	  
	<span class="token comment"># we now clip any distance that falls outside of our bounds</span>
	w <span class="token operator">=</span> np<span class="token punctuation">.</span>clip<span class="token punctuation">(</span>dist<span class="token punctuation">(</span>x<span class="token punctuation">,</span>x<span class="token punctuation">)</span> <span class="token operator">/</span> h<span class="token punctuation">,</span>  <span class="token number">0.0</span><span class="token punctuation">,</span>  <span class="token number">1.0</span><span class="token punctuation">)</span>
	  
	<span class="token comment"># we apply our kernel to get the weights, giving closer neighbors more weight</span>
	<span class="token comment"># by default, we use tricubic, however, the user may specify an alternate</span>
	<span class="token keyword">if</span> kernel <span class="token keyword">in</span>  <span class="token punctuation">{</span><span class="token string">'Quartic'</span><span class="token punctuation">,</span><span class="token string">'quartic'</span><span class="token punctuation">,</span><span class="token string">'q'</span><span class="token punctuation">}</span><span class="token punctuation">:</span>
		w <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> w <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">2</span>
	<span class="token keyword">elif</span> kernel <span class="token keyword">in</span>  <span class="token punctuation">{</span><span class="token string">'Epanechnikov'</span><span class="token punctuation">,</span><span class="token string">'epanechnikov'</span><span class="token punctuation">,</span><span class="token string">'ep'</span><span class="token punctuation">}</span><span class="token punctuation">:</span>
		w <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> w <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span>
	<span class="token keyword">elif</span> kernel <span class="token keyword">in</span>  <span class="token punctuation">{</span><span class="token string">'Exponential'</span><span class="token punctuation">,</span><span class="token string">'exponential'</span><span class="token punctuation">,</span><span class="token string">'ex'</span><span class="token punctuation">,</span><span class="token string">'exp'</span><span class="token punctuation">,</span><span class="token string">'Gaussian'</span><span class="token punctuation">,</span><span class="token string">'gaussian'</span><span class="token punctuation">,</span><span class="token string">'g'</span><span class="token punctuation">}</span><span class="token punctuation">:</span>
		w <span class="token operator">=</span> np<span class="token punctuation">.</span>exp<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span><span class="token operator">*</span>w<span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">)</span>
	<span class="token keyword">else</span><span class="token punctuation">:</span>
		w <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> w <span class="token operator">**</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">3</span>
	  
	<span class="token comment"># initialize our y estimate and delta</span>
	yest <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>n<span class="token punctuation">)</span>
	delta <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span>n<span class="token punctuation">)</span>
	  
	<span class="token keyword">for</span> iteration <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">iter</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
		<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
			<span class="token comment"># convert our weights to a diagonal matrix</span>
			W <span class="token operator">=</span> np<span class="token punctuation">.</span>diag<span class="token punctuation">(</span>delta<span class="token punctuation">)</span><span class="token punctuation">.</span>dot<span class="token punctuation">(</span>np<span class="token punctuation">.</span>diag<span class="token punctuation">(</span>w<span class="token punctuation">[</span>i<span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

			<span class="token comment"># this is our ordinate values</span>
			b <span class="token operator">=</span> np<span class="token punctuation">.</span>transpose<span class="token punctuation">(</span>x1<span class="token punctuation">)</span><span class="token punctuation">.</span>dot<span class="token punctuation">(</span>W<span class="token punctuation">)</span><span class="token punctuation">.</span>dot<span class="token punctuation">(</span>y<span class="token punctuation">)</span>

			<span class="token comment"># this is our coefficient matrix</span>
			A <span class="token operator">=</span> np<span class="token punctuation">.</span>transpose<span class="token punctuation">(</span>x1<span class="token punctuation">)</span><span class="token punctuation">.</span>dot<span class="token punctuation">(</span>W<span class="token punctuation">)</span><span class="token punctuation">.</span>dot<span class="token punctuation">(</span>x1<span class="token punctuation">)</span>
			  
			<span class="token comment"># L2 regularization, this ensures that our matrix equation can always be solved</span>
			A <span class="token operator">=</span> A <span class="token operator">+</span> <span class="token number">0.0001</span><span class="token operator">*</span>np<span class="token punctuation">.</span>eye<span class="token punctuation">(</span>x1<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

			<span class="token comment"># finally, we solve our matrix equation</span>
			beta <span class="token operator">=</span> linalg<span class="token punctuation">.</span>solve<span class="token punctuation">(</span>A<span class="token punctuation">,</span> b<span class="token punctuation">)</span>

			<span class="token comment"># create the y estimate</span>
			yest<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> np<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>x1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>beta<span class="token punctuation">)</span>

		<span class="token comment"># now we get the residuals and calculate our cutoff for outliers</span>
		residuals <span class="token operator">=</span> y <span class="token operator">-</span> yest

		<span class="token comment"># quartiles and IQR</span>
		Q1 <span class="token operator">=</span> np<span class="token punctuation">.</span>percentile<span class="token punctuation">(</span>residuals<span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">)</span>
		Q3 <span class="token operator">=</span> np<span class="token punctuation">.</span>percentile<span class="token punctuation">(</span>residuals<span class="token punctuation">,</span><span class="token number">75</span><span class="token punctuation">)</span>
		IQR <span class="token operator">=</span> Q3<span class="token operator">-</span>Q1

		<span class="token comment"># upper and lower bound for outliers</span>
		upper <span class="token operator">=</span> Q3 <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1.5</span> <span class="token operator">*</span> IQR<span class="token punctuation">)</span>
		lower <span class="token operator">=</span> Q1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1.5</span> <span class="token operator">*</span> IQR<span class="token punctuation">)</span>
		  
		<span class="token comment"># these values help us standardize the data to have the lower bound be -1</span>
		<span class="token comment"># and the upper bound be 1</span>
		mid <span class="token operator">=</span> <span class="token punctuation">(</span>upper <span class="token operator">+</span> lower<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span>
		div <span class="token operator">=</span> upper<span class="token operator">-</span>mid

		<span class="token comment"># finally, we clip all outliers</span>
		delta <span class="token operator">=</span> np<span class="token punctuation">.</span>clip<span class="token punctuation">(</span><span class="token punctuation">(</span>residuals <span class="token operator">-</span> mid<span class="token punctuation">)</span><span class="token operator">/</span>div<span class="token punctuation">,</span>  <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">)</span>
		delta <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> delta <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">2</span>

	<span class="token comment"># this is how we handle training and testing data (x, xnew)</span>
	<span class="token keyword">if</span> x<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>
		<span class="token comment"># this is a one dimensional interpolator</span>
		f <span class="token operator">=</span> interp1d<span class="token punctuation">(</span>x<span class="token punctuation">.</span>flatten<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>yest<span class="token punctuation">,</span>fill_value<span class="token operator">=</span><span class="token string">'extrapolate'</span><span class="token punctuation">)</span>
		output <span class="token operator">=</span> f<span class="token punctuation">(</span>xnew<span class="token punctuation">)</span>

	<span class="token keyword">else</span><span class="token punctuation">:</span>
		<span class="token comment"># otherwise, we need to use principal component analysis on our higher dimensional data</span>
		<span class="token comment"># this is because there may be relationships between some of the features</span>
		output <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>xnew<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>xnew<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
			ind <span class="token operator">=</span> np<span class="token punctuation">.</span>argsort<span class="token punctuation">(</span>np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token operator">-</span>xnew<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">,</span>axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span>r<span class="token punctuation">]</span>
			pca <span class="token operator">=</span> PCA<span class="token punctuation">(</span>n_components<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span>
			x_pca <span class="token operator">=</span> pca<span class="token punctuation">.</span>fit_transform<span class="token punctuation">(</span>x<span class="token punctuation">[</span>ind<span class="token punctuation">]</span><span class="token punctuation">)</span>
			tri <span class="token operator">=</span> Delaunay<span class="token punctuation">(</span>x_pca<span class="token punctuation">,</span>qhull_options<span class="token operator">=</span><span class="token string">'QJ'</span><span class="token punctuation">)</span>
			f <span class="token operator">=</span> LinearNDInterpolator<span class="token punctuation">(</span>tri<span class="token punctuation">,</span>y<span class="token punctuation">[</span>ind<span class="token punctuation">]</span><span class="token punctuation">)</span>
			output<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">(</span>pca<span class="token punctuation">.</span>transform<span class="token punctuation">(</span>xnew<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

	<span class="token comment"># the output may have NaN's where the data points from xnew are outside the convex hull of X</span>
	<span class="token comment"># here, we will resolve that with nearest neighbor interpolation in higher dimensions</span>
	<span class="token keyword">if</span> <span class="token builtin">sum</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>isnan<span class="token punctuation">(</span>output<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">:</span>
		g <span class="token operator">=</span> NearestNDInterpolator<span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">.</span>ravel<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		output<span class="token punctuation">[</span>np<span class="token punctuation">.</span>isnan<span class="token punctuation">(</span>output<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> g<span class="token punctuation">(</span>xnew<span class="token punctuation">[</span>np<span class="token punctuation">.</span>isnan<span class="token punctuation">(</span>output<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

	<span class="token keyword">return</span> output
</code></pre>
<h2 id="application-of-the-multidimensional-function-using-real-data">Application of the Multidimensional Function Using Real Data</h2>
<p>Now, to actually apply our function, let’s look at some real data. Here, we have a sample of observations from the cars.csv dataset: <a href="data.png">Cars Dataset</a><br>
We need to grab the x and y values from this dataset, where y is mpg and x is all other features:</p>
<pre class=" language-python"><code class="prism  language-python">x <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'CYL'</span><span class="token punctuation">,</span><span class="token string">'ENG'</span><span class="token punctuation">,</span><span class="token string">'WGT'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>values
y <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token string">'MPG'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>values
</code></pre>
<h3 id="k-fold-cross-validation">K-Fold Cross Validation</h3>
<p>We will be performing cross validation with training and testing sets. This will be compared to the results of a Random Forest Regressor and the alternate Locally Weighted Regressor. First, we need to instantiate lists for holding our mse’s (mean squared errors), our KFold object, and our three models:</p>
<pre class=" language-python"><code class="prism  language-python">mse_lw_ag <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
mse_lw <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
mse_rf <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

kf <span class="token operator">=</span> KFold<span class="token punctuation">(</span>n_splits<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span>shuffle<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>random_state<span class="token operator">=</span><span class="token number">1234</span><span class="token punctuation">)</span>

model_rf <span class="token operator">=</span> RandomForestRegressor<span class="token punctuation">(</span>n_estimators<span class="token operator">=</span><span class="token number">200</span><span class="token punctuation">,</span>max_depth<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span>
model_lw <span class="token operator">=</span> Lowess<span class="token punctuation">(</span>kernel<span class="token operator">=</span>Tricubic<span class="token punctuation">,</span>tau<span class="token operator">=</span><span class="token number">0.02</span><span class="token punctuation">)</span>
model_lw_ag <span class="token operator">=</span> Lowess_AG_MD<span class="token punctuation">(</span>f<span class="token operator">=</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">65</span><span class="token punctuation">,</span><span class="token builtin">iter</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span>intercept<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>kernel<span class="token operator">=</span><span class="token string">'tricubic'</span><span class="token punctuation">)</span>
</code></pre>
<p>Now we can perform our fitting and predicting for each subset of training and testing data:</p>
<pre class=" language-python"><code class="prism  language-python"><span class="token keyword">for</span> idxtrain<span class="token punctuation">,</span> idxtest <span class="token keyword">in</span> kf<span class="token punctuation">.</span>split<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
	xtrain <span class="token operator">=</span> x<span class="token punctuation">[</span>idxtrain<span class="token punctuation">]</span>
	ytrain <span class="token operator">=</span> y<span class="token punctuation">[</span>idxtrain<span class="token punctuation">]</span>
	ytest <span class="token operator">=</span> y<span class="token punctuation">[</span>idxtest<span class="token punctuation">]</span>
	xtest <span class="token operator">=</span> x<span class="token punctuation">[</span>idxtest<span class="token punctuation">]</span>
	xtrain <span class="token operator">=</span> scale<span class="token punctuation">.</span>fit_transform<span class="token punctuation">(</span>xtrain<span class="token punctuation">)</span>
	xtest <span class="token operator">=</span> scale<span class="token punctuation">.</span>transform<span class="token punctuation">(</span>xtest<span class="token punctuation">)</span>
	  
	model_lw_ag<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>xtrain<span class="token punctuation">,</span>ytrain<span class="token punctuation">)</span>
	yhat_lw_ag <span class="token operator">=</span> model_lw_ag<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>xtest<span class="token punctuation">)</span>  

	model_lw<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>xtrain<span class="token punctuation">,</span>ytrain<span class="token punctuation">)</span>
	yhat_lw <span class="token operator">=</span> model_lw<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>xtest<span class="token punctuation">)</span>

	model_rf<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>xtrain<span class="token punctuation">,</span>ytrain<span class="token punctuation">)</span>
	yhat_rf <span class="token operator">=</span> model_rf<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>xtest<span class="token punctuation">)</span>
	  
	mse_lw_ag<span class="token punctuation">.</span>append<span class="token punctuation">(</span>mse<span class="token punctuation">(</span>ytest<span class="token punctuation">,</span>yhat_lw_ag<span class="token punctuation">)</span><span class="token punctuation">)</span>
	mse_lw<span class="token punctuation">.</span>append<span class="token punctuation">(</span>mse<span class="token punctuation">(</span>ytest<span class="token punctuation">,</span>yhat_lw<span class="token punctuation">)</span><span class="token punctuation">)</span>
	mse_rf<span class="token punctuation">.</span>append<span class="token punctuation">(</span>mse<span class="token punctuation">(</span>ytest<span class="token punctuation">,</span>yhat_rf<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
<p>If we take a look at our mse’s, we find that the Random Forest, Locally Weighted, and Gramfort Locally Weighted Regressors get values of approximately 17.2, 24, and 26. Although our function was the worst performing here, that does not mean it is bad, we just need to tune our hyperparameters. In order to do that, we need to first make our function SciKitLearn-Compliant.</p>
<h2 id="adapting-our-function-to-be-scikitlearn-compliant">Adapting Our Function to be SciKitLearn-Compliant</h2>
<p>In order to have our function be SciKitLearn-Compliant, we need to have a wrapper class with the following functions: __init__, fit, predict, get_params, and set_params. We need __init__ to have matching parameters with our multidimensional function, we need fit to have the training parameters, x and y, and we need to feed predict our x_new or testing data. This is what the wrapper looks like:</p>
<pre class=" language-python"><code class="prism  language-python"><span class="token keyword">class</span> <span class="token class-name">Lowess_AG_MD</span><span class="token punctuation">:</span>
	<span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> f <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token builtin">iter</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span>intercept<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> kernel<span class="token operator">=</span><span class="token string">'tricubic'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
		self<span class="token punctuation">.</span>f <span class="token operator">=</span> f
		self<span class="token punctuation">.</span><span class="token builtin">iter</span> <span class="token operator">=</span> <span class="token builtin">iter</span>
		self<span class="token punctuation">.</span>intercept <span class="token operator">=</span> intercept
		self<span class="token punctuation">.</span>kernel <span class="token operator">=</span> kernel

	<span class="token keyword">def</span> <span class="token function">fit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>
		f <span class="token operator">=</span> self<span class="token punctuation">.</span>f
		<span class="token builtin">iter</span> <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token builtin">iter</span>
		self<span class="token punctuation">.</span>xtrain_ <span class="token operator">=</span> x
		self<span class="token punctuation">.</span>yhat_ <span class="token operator">=</span> y
	  
	<span class="token keyword">def</span> <span class="token function">predict</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x_new<span class="token punctuation">)</span><span class="token punctuation">:</span>
		check_is_fitted<span class="token punctuation">(</span>self<span class="token punctuation">)</span>
		x <span class="token operator">=</span> self<span class="token punctuation">.</span>xtrain_
		y <span class="token operator">=</span> self<span class="token punctuation">.</span>yhat_
		f <span class="token operator">=</span> self<span class="token punctuation">.</span>f
		<span class="token builtin">iter</span> <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token builtin">iter</span>
		intercept <span class="token operator">=</span> self<span class="token punctuation">.</span>intercept
		kernel <span class="token operator">=</span> self<span class="token punctuation">.</span>kernel
		<span class="token keyword">return</span> lowess_ag_md<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> x_new<span class="token punctuation">,</span> f<span class="token punctuation">,</span> <span class="token builtin">iter</span><span class="token punctuation">,</span> intercept<span class="token punctuation">,</span> kernel<span class="token punctuation">)</span>
	  
	<span class="token keyword">def</span> <span class="token function">get_params</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> deep<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
		<span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token string">"f"</span><span class="token punctuation">:</span>self<span class="token punctuation">.</span>f<span class="token punctuation">,</span><span class="token string">"iter"</span><span class="token punctuation">:</span> self<span class="token punctuation">.</span><span class="token builtin">iter</span><span class="token punctuation">,</span><span class="token string">"intercept"</span><span class="token punctuation">:</span>self<span class="token punctuation">.</span>intercept<span class="token punctuation">,</span><span class="token string">"kernel"</span><span class="token punctuation">:</span>self<span class="token punctuation">.</span>kernel<span class="token punctuation">}</span>
	  
	<span class="token keyword">def</span> <span class="token function">set_params</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token operator">**</span>parameters<span class="token punctuation">)</span><span class="token punctuation">:</span>
		<span class="token keyword">for</span> parameter<span class="token punctuation">,</span> value <span class="token keyword">in</span> parameters<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
			<span class="token builtin">setattr</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> parameter<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
		<span class="token keyword">return</span> self
</code></pre>
<h3 id="gridsearchcv">GridSearchCV</h3>
<p>We now perform a grid search to optimize our hyperparameters. We will specifically look at the parameters: f, iter, and kernel. We first need to create a pipeline for our grid search:</p>
<pre class=" language-python"><code class="prism  language-python">lwr_pipe <span class="token operator">=</span> Pipeline<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'zscores'</span><span class="token punctuation">,</span> StandardScaler<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'lwr'</span><span class="token punctuation">,</span> Lowess_AG_MD<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre>
<p>Then, we specify the parameters we want to consider, accompanied by an iterable that contains the possible values for those parameters:</p>
<pre class=" language-python"><code class="prism  language-python">params <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">'lwr__f'</span><span class="token punctuation">:</span>  <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">/</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span>  <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
		   <span class="token string">'lwr__iter'</span><span class="token punctuation">:</span>  <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
		   <span class="token string">'lwr__kernel'</span><span class="token punctuation">:</span>  <span class="token punctuation">[</span><span class="token string">'Tricubic'</span><span class="token punctuation">,</span><span class="token string">'Quartic'</span><span class="token punctuation">,</span><span class="token string">'Epanechnikov'</span><span class="token punctuation">,</span><span class="token string">'Exponential'</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">]</span>
</code></pre>
<p>Lastly, we perform the grid search:</p>
<pre class=" language-python"><code class="prism  language-python">gs_lowess <span class="token operator">=</span> GridSearchCV<span class="token punctuation">(</span>lwr_pipe<span class="token punctuation">,</span>
						 param_grid<span class="token operator">=</span>params<span class="token punctuation">,</span>
						 scoring<span class="token operator">=</span><span class="token string">'neg_mean_squared_error'</span><span class="token punctuation">,</span>
						 cv<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span>

gs_lowess<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span>
</code></pre>
<p>From this, we find that our optimal hyperparameters are f=1/3, iter=1 and kernel=Tricubic. Let’s see how these paremeters perform.</p>
<h3 id="optimized-results">Optimized Results</h3>
<pre class=" language-python"><code class="prism  language-python">mse_lw_ag <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
kf <span class="token operator">=</span> KFold<span class="token punctuation">(</span>n_splits<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span>shuffle<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>random_state<span class="token operator">=</span><span class="token number">1234</span><span class="token punctuation">)</span>
model_lw_ag <span class="token operator">=</span> Lowess_AG_MD<span class="token punctuation">(</span>f<span class="token operator">=</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token builtin">iter</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>intercept<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>kernel<span class="token operator">=</span><span class="token string">'tricubic'</span><span class="token punctuation">)</span>
  
<span class="token keyword">for</span> idxtrain<span class="token punctuation">,</span> idxtest <span class="token keyword">in</span> kf<span class="token punctuation">.</span>split<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
	xtrain <span class="token operator">=</span> x<span class="token punctuation">[</span>idxtrain<span class="token punctuation">]</span>
	ytrain <span class="token operator">=</span> y<span class="token punctuation">[</span>idxtrain<span class="token punctuation">]</span>
	ytest <span class="token operator">=</span> y<span class="token punctuation">[</span>idxtest<span class="token punctuation">]</span>
	xtest <span class="token operator">=</span> x<span class="token punctuation">[</span>idxtest<span class="token punctuation">]</span>
	xtrain <span class="token operator">=</span> scale<span class="token punctuation">.</span>fit_transform<span class="token punctuation">(</span>xtrain<span class="token punctuation">)</span>
	xtest <span class="token operator">=</span> scale<span class="token punctuation">.</span>transform<span class="token punctuation">(</span>xtest<span class="token punctuation">)</span>
	  
	model_lw_ag<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>xtrain<span class="token punctuation">,</span>ytrain<span class="token punctuation">)</span>
	yhat_lw_ag <span class="token operator">=</span> model_lw_ag<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>xtest<span class="token punctuation">)</span>
	  
	mse_lw_ag<span class="token punctuation">.</span>append<span class="token punctuation">(</span>mse<span class="token punctuation">(</span>ytest<span class="token punctuation">,</span>yhat_lw_ag<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
<p>After running a K-Fold Cross Validation again with our optimal parameters, our mse has decreased to about 23.5. This is good, as we want this error to be as low as possible. We could likely continue tuning our parameters further to yield better results, however this has been a good illustration of the power of our Gramfort Multidimensional function and the importance of tuning parameters.</p>
</div>
</body>

</html>
